Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> prog
Rule 1     prog -> comandos
Rule 2     comandos -> <empty>
Rule 3     comandos -> CONST comandos
Rule 4     comandos -> $ VAR $ comandos
Rule 5     comandos -> IF VAR ) $ comandos alternative ENDIF comandos
Rule 6     comandos -> FOR VAR ) $ comandos ENDFOR comandos
Rule 7     alternative -> <empty>
Rule 8     alternative -> condition_sing
Rule 9     alternative -> condition_rec
Rule 10    condition_sing -> ELSE comandos
Rule 11    condition_rec -> <empty>
Rule 12    condition_rec -> ELSEIF VAR ) $ comandos condition_rec

Terminals, with rules where they appear

$                    : 4 4 5 6 12
)                    : 5 6 12
CONST                : 3
ELSE                 : 10
ELSEIF               : 12
ENDFOR               : 6
ENDIF                : 5
FOR                  : 6
IF                   : 5
VAR                  : 4 5 6 12
error                : 

Nonterminals, with rules where they appear

alternative          : 5
comandos             : 1 3 4 5 5 6 6 10 12
condition_rec        : 9 12
condition_sing       : 8
prog                 : 0

Parsing method: LALR

state 0

    (0) S' -> . prog
    (1) prog -> . comandos
    (2) comandos -> .
    (3) comandos -> . CONST comandos
    (4) comandos -> . $ VAR $ comandos
    (5) comandos -> . IF VAR ) $ comandos alternative ENDIF comandos
    (6) comandos -> . FOR VAR ) $ comandos ENDFOR comandos

    $end            reduce using rule 2 (comandos -> .)
    CONST           shift and go to state 3
    $               shift and go to state 4
    IF              shift and go to state 5
    FOR             shift and go to state 6

    prog                           shift and go to state 1
    comandos                       shift and go to state 2

state 1

    (0) S' -> prog .



state 2

    (1) prog -> comandos .

    $end            reduce using rule 1 (prog -> comandos .)


state 3

    (3) comandos -> CONST . comandos
    (2) comandos -> .
    (3) comandos -> . CONST comandos
    (4) comandos -> . $ VAR $ comandos
    (5) comandos -> . IF VAR ) $ comandos alternative ENDIF comandos
    (6) comandos -> . FOR VAR ) $ comandos ENDFOR comandos

    $end            reduce using rule 2 (comandos -> .)
    ELSE            reduce using rule 2 (comandos -> .)
    ELSEIF          reduce using rule 2 (comandos -> .)
    ENDIF           reduce using rule 2 (comandos -> .)
    ENDFOR          reduce using rule 2 (comandos -> .)
    CONST           shift and go to state 3
    $               shift and go to state 4
    IF              shift and go to state 5
    FOR             shift and go to state 6

    comandos                       shift and go to state 7

state 4

    (4) comandos -> $ . VAR $ comandos

    VAR             shift and go to state 8


state 5

    (5) comandos -> IF . VAR ) $ comandos alternative ENDIF comandos

    VAR             shift and go to state 9


state 6

    (6) comandos -> FOR . VAR ) $ comandos ENDFOR comandos

    VAR             shift and go to state 10


state 7

    (3) comandos -> CONST comandos .

    $end            reduce using rule 3 (comandos -> CONST comandos .)
    ELSE            reduce using rule 3 (comandos -> CONST comandos .)
    ELSEIF          reduce using rule 3 (comandos -> CONST comandos .)
    ENDIF           reduce using rule 3 (comandos -> CONST comandos .)
    ENDFOR          reduce using rule 3 (comandos -> CONST comandos .)


state 8

    (4) comandos -> $ VAR . $ comandos

    $               shift and go to state 11


state 9

    (5) comandos -> IF VAR . ) $ comandos alternative ENDIF comandos

    )               shift and go to state 12


state 10

    (6) comandos -> FOR VAR . ) $ comandos ENDFOR comandos

    )               shift and go to state 13


state 11

    (4) comandos -> $ VAR $ . comandos
    (2) comandos -> .
    (3) comandos -> . CONST comandos
    (4) comandos -> . $ VAR $ comandos
    (5) comandos -> . IF VAR ) $ comandos alternative ENDIF comandos
    (6) comandos -> . FOR VAR ) $ comandos ENDFOR comandos

    $end            reduce using rule 2 (comandos -> .)
    ELSE            reduce using rule 2 (comandos -> .)
    ELSEIF          reduce using rule 2 (comandos -> .)
    ENDIF           reduce using rule 2 (comandos -> .)
    ENDFOR          reduce using rule 2 (comandos -> .)
    CONST           shift and go to state 3
    $               shift and go to state 4
    IF              shift and go to state 5
    FOR             shift and go to state 6

    comandos                       shift and go to state 14

state 12

    (5) comandos -> IF VAR ) . $ comandos alternative ENDIF comandos

    $               shift and go to state 15


state 13

    (6) comandos -> FOR VAR ) . $ comandos ENDFOR comandos

    $               shift and go to state 16


state 14

    (4) comandos -> $ VAR $ comandos .

    $end            reduce using rule 4 (comandos -> $ VAR $ comandos .)
    ELSE            reduce using rule 4 (comandos -> $ VAR $ comandos .)
    ELSEIF          reduce using rule 4 (comandos -> $ VAR $ comandos .)
    ENDIF           reduce using rule 4 (comandos -> $ VAR $ comandos .)
    ENDFOR          reduce using rule 4 (comandos -> $ VAR $ comandos .)


state 15

    (5) comandos -> IF VAR ) $ . comandos alternative ENDIF comandos
    (2) comandos -> .
    (3) comandos -> . CONST comandos
    (4) comandos -> . $ VAR $ comandos
    (5) comandos -> . IF VAR ) $ comandos alternative ENDIF comandos
    (6) comandos -> . FOR VAR ) $ comandos ENDFOR comandos

    ELSE            reduce using rule 2 (comandos -> .)
    ELSEIF          reduce using rule 2 (comandos -> .)
    ENDIF           reduce using rule 2 (comandos -> .)
    CONST           shift and go to state 3
    $               shift and go to state 4
    IF              shift and go to state 5
    FOR             shift and go to state 6

    comandos                       shift and go to state 17

state 16

    (6) comandos -> FOR VAR ) $ . comandos ENDFOR comandos
    (2) comandos -> .
    (3) comandos -> . CONST comandos
    (4) comandos -> . $ VAR $ comandos
    (5) comandos -> . IF VAR ) $ comandos alternative ENDIF comandos
    (6) comandos -> . FOR VAR ) $ comandos ENDFOR comandos

    ENDFOR          reduce using rule 2 (comandos -> .)
    CONST           shift and go to state 3
    $               shift and go to state 4
    IF              shift and go to state 5
    FOR             shift and go to state 6

    comandos                       shift and go to state 18

state 17

    (5) comandos -> IF VAR ) $ comandos . alternative ENDIF comandos
    (7) alternative -> .
    (8) alternative -> . condition_sing
    (9) alternative -> . condition_rec
    (10) condition_sing -> . ELSE comandos
    (11) condition_rec -> .
    (12) condition_rec -> . ELSEIF VAR ) $ comandos condition_rec

  ! reduce/reduce conflict for ENDIF resolved using rule 7 (alternative -> .)
    ENDIF           reduce using rule 7 (alternative -> .)
    ELSE            shift and go to state 22
    ELSEIF          shift and go to state 23

  ! ENDIF           [ reduce using rule 11 (condition_rec -> .) ]

    alternative                    shift and go to state 19
    condition_sing                 shift and go to state 20
    condition_rec                  shift and go to state 21

state 18

    (6) comandos -> FOR VAR ) $ comandos . ENDFOR comandos

    ENDFOR          shift and go to state 24


state 19

    (5) comandos -> IF VAR ) $ comandos alternative . ENDIF comandos

    ENDIF           shift and go to state 25


state 20

    (8) alternative -> condition_sing .

    ENDIF           reduce using rule 8 (alternative -> condition_sing .)


state 21

    (9) alternative -> condition_rec .

    ENDIF           reduce using rule 9 (alternative -> condition_rec .)


state 22

    (10) condition_sing -> ELSE . comandos
    (2) comandos -> .
    (3) comandos -> . CONST comandos
    (4) comandos -> . $ VAR $ comandos
    (5) comandos -> . IF VAR ) $ comandos alternative ENDIF comandos
    (6) comandos -> . FOR VAR ) $ comandos ENDFOR comandos

    ENDIF           reduce using rule 2 (comandos -> .)
    CONST           shift and go to state 3
    $               shift and go to state 4
    IF              shift and go to state 5
    FOR             shift and go to state 6

    comandos                       shift and go to state 26

state 23

    (12) condition_rec -> ELSEIF . VAR ) $ comandos condition_rec

    VAR             shift and go to state 27


state 24

    (6) comandos -> FOR VAR ) $ comandos ENDFOR . comandos
    (2) comandos -> .
    (3) comandos -> . CONST comandos
    (4) comandos -> . $ VAR $ comandos
    (5) comandos -> . IF VAR ) $ comandos alternative ENDIF comandos
    (6) comandos -> . FOR VAR ) $ comandos ENDFOR comandos

    $end            reduce using rule 2 (comandos -> .)
    ELSE            reduce using rule 2 (comandos -> .)
    ELSEIF          reduce using rule 2 (comandos -> .)
    ENDIF           reduce using rule 2 (comandos -> .)
    ENDFOR          reduce using rule 2 (comandos -> .)
    CONST           shift and go to state 3
    $               shift and go to state 4
    IF              shift and go to state 5
    FOR             shift and go to state 6

    comandos                       shift and go to state 28

state 25

    (5) comandos -> IF VAR ) $ comandos alternative ENDIF . comandos
    (2) comandos -> .
    (3) comandos -> . CONST comandos
    (4) comandos -> . $ VAR $ comandos
    (5) comandos -> . IF VAR ) $ comandos alternative ENDIF comandos
    (6) comandos -> . FOR VAR ) $ comandos ENDFOR comandos

    $end            reduce using rule 2 (comandos -> .)
    ELSE            reduce using rule 2 (comandos -> .)
    ELSEIF          reduce using rule 2 (comandos -> .)
    ENDIF           reduce using rule 2 (comandos -> .)
    ENDFOR          reduce using rule 2 (comandos -> .)
    CONST           shift and go to state 3
    $               shift and go to state 4
    IF              shift and go to state 5
    FOR             shift and go to state 6

    comandos                       shift and go to state 29

state 26

    (10) condition_sing -> ELSE comandos .

    ENDIF           reduce using rule 10 (condition_sing -> ELSE comandos .)


state 27

    (12) condition_rec -> ELSEIF VAR . ) $ comandos condition_rec

    )               shift and go to state 30


state 28

    (6) comandos -> FOR VAR ) $ comandos ENDFOR comandos .

    $end            reduce using rule 6 (comandos -> FOR VAR ) $ comandos ENDFOR comandos .)
    ELSE            reduce using rule 6 (comandos -> FOR VAR ) $ comandos ENDFOR comandos .)
    ELSEIF          reduce using rule 6 (comandos -> FOR VAR ) $ comandos ENDFOR comandos .)
    ENDIF           reduce using rule 6 (comandos -> FOR VAR ) $ comandos ENDFOR comandos .)
    ENDFOR          reduce using rule 6 (comandos -> FOR VAR ) $ comandos ENDFOR comandos .)


state 29

    (5) comandos -> IF VAR ) $ comandos alternative ENDIF comandos .

    $end            reduce using rule 5 (comandos -> IF VAR ) $ comandos alternative ENDIF comandos .)
    ELSE            reduce using rule 5 (comandos -> IF VAR ) $ comandos alternative ENDIF comandos .)
    ELSEIF          reduce using rule 5 (comandos -> IF VAR ) $ comandos alternative ENDIF comandos .)
    ENDIF           reduce using rule 5 (comandos -> IF VAR ) $ comandos alternative ENDIF comandos .)
    ENDFOR          reduce using rule 5 (comandos -> IF VAR ) $ comandos alternative ENDIF comandos .)


state 30

    (12) condition_rec -> ELSEIF VAR ) . $ comandos condition_rec

    $               shift and go to state 31


state 31

    (12) condition_rec -> ELSEIF VAR ) $ . comandos condition_rec
    (2) comandos -> .
    (3) comandos -> . CONST comandos
    (4) comandos -> . $ VAR $ comandos
    (5) comandos -> . IF VAR ) $ comandos alternative ENDIF comandos
    (6) comandos -> . FOR VAR ) $ comandos ENDFOR comandos

    ELSEIF          reduce using rule 2 (comandos -> .)
    ENDIF           reduce using rule 2 (comandos -> .)
    CONST           shift and go to state 3
    $               shift and go to state 4
    IF              shift and go to state 5
    FOR             shift and go to state 6

    comandos                       shift and go to state 32

state 32

    (12) condition_rec -> ELSEIF VAR ) $ comandos . condition_rec
    (11) condition_rec -> .
    (12) condition_rec -> . ELSEIF VAR ) $ comandos condition_rec

    ENDIF           reduce using rule 11 (condition_rec -> .)
    ELSEIF          shift and go to state 23

    condition_rec                  shift and go to state 33

state 33

    (12) condition_rec -> ELSEIF VAR ) $ comandos condition_rec .

    ENDIF           reduce using rule 12 (condition_rec -> ELSEIF VAR ) $ comandos condition_rec .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 17 resolved using rule (alternative -> <empty>)
WARNING: rejected rule (condition_rec -> <empty>) in state 17
